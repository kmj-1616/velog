<h1 id="bronze-ii-ox퀴즈---8958">[Bronze II] OX퀴즈 - 8958</h1>
<p><a href="https://www.acmicpc.net/problem/8958">문제 링크</a></p>
<h3 id="문제-설명">문제 설명</h3>
<p><img alt="" src="https://velog.velcdn.com/images/kmj-1616/post/a4fbfe52-a4a8-433c-8e2f-cf636e6395bd/image.png" /></p>
<h3 id="제출-코드">제출 코드</h3>
<pre><code>T = int(input())

for _ in range(1, T+1):
    string = input()
    stack = []
    score = 0   # 점수 기록

    for ch in string:    # OX 결과를 확인하는데
        if ch == 'O':    # O면 push하고
            stack.append(ch)
            score += len(stack) # 스택 길이(O의 개수)만큼 점수 추가
        else:       # X면 스택 비우고 다음 확인  
            stack.clear()
    print(score)</code></pre><ul>
<li>O이면 리스트에 추가하고 그 길이만큼 점수를 추가하고, X가 나오면 비우는 로직으로 작성했다.</li>
<li>최근 stack을 배워서 연습해보고자 top 인덱스를 사용해서 풀려고 했는데, 풀다 보니 누적 점수를 계산해야 해서 append 외엔 다른 게 딱히 필요하지 않았다. (일단은 자료구조 연습용으로 하던 거 제출함)</li>
</ul>
<h3 id="다른-코드">다른 코드</h3>
<p>내 코드는 메모리 32412KB, 시간 40ms였는데 다른 파이썬 코드들은 31120KB, 시간 32ms여서 확인해 봤다.</p>
<pre><code>T = int(input())

for _ in range(T):
    string = input()
    score = 0
    combo = 0            # 누적된 O의 개수를 저장하는 변수 
    for ch in string:
        if ch == 'O':
            combo += 1    # O이면 콤보 추가 
            score += combo
        else:
            combo = 0    # X가 나오면 다시 0으로 초기화 
    print(score)</code></pre><p>이렇게 누적 개수를 세는 변수를 사용하면, 리스트 연산을 하지 않아도 돼서 메모리를 덜 사용하고 시간이 빠르다.</p>